defmodule Cashu.ProofV3 do
  @moduledoc """
  NUT-00: Proof
  A Proof is also called an input and is generated by Alice from a BlindedSignature it received. An array [Proof] is called Proofs. Alice sends Proofs to Bob for melting tokens. Serialized Proofs can also be sent from Alice to Carol. Upon receiving the token, Carol deserializes it and requests a swap from Bob to receive new Proofs.
  """
  alias Cashu.{BDHKE, Error, Validator}
  alias Bitcoinex.Secp256k1.Point

  defstruct id: "", amount: 0, secret: "", c: ""

  @type t :: %{
          id: String.t(),
          amount: pos_integer(),
          secret: String.t(),
          c: String.t()
        }

  def new(), do: %__MODULE__{}
  def new(params) when is_list(params), do: struct!(__MODULE__, params)
  def new(params) when is_map(params), do: Map.to_list(params) |> new()

  def new(c_prime, secret, amount, keyset_id, mint_pubkey) do
    case BDHKE.generate_proof(c_prime, secret, mint_pubkey) do
      {:ok, %Point{} = c} ->
        hex_c = Point.serialize_public_key(c)
        new(amount: amount, id: keyset_id, secret: secret, c: hex_c)

      {:error, reason} ->
        Error.new(reason)
    end
  end

  def validate(_), do: {:ok, nil}

  def validate_proof_list(list), do: Validator.validate_list(list, &validate/1)
end

defimpl Jason.Encoder, for: Cashu.ProofV3 do
  def encode(struct, opts) do
    Jason.Encode.keyword(
      [
        amount: struct.amount,
        id: struct.id,
        secret: struct.secret,
        C: struct.c
      ],
      opts
    )
  end
end
